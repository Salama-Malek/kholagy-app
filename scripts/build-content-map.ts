import { promises as fs } from 'fs';
import type { Stats } from 'fs';
import path from 'path';

const CONTENT_DIR = path.resolve(__dirname, '..', 'content');
const OUTPUT_FILE = path.resolve(__dirname, '..', 'src', 'contentMap.ts');
const SYNAXARIUM_DIR = path.resolve(CONTENT_DIR, 'synaxarium');
const SYNAXARIUM_OUTPUT_FILE = path.resolve(__dirname, '..', 'src', 'api', 'synaxariumMap.ts');

interface Entry {
  key: string;
  importPath: string;
}

async function collectMarkdownFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        return collectMarkdownFiles(fullPath);
      }
      if (entry.isFile() && entry.name.endsWith('.md')) {
        return [fullPath];
      }
      return [];
    })
  );

  return files.flat();
}

async function collectSynaxariumFiles(dir: string): Promise<string[]> {
  let stats: Stats;
  try {
    stats = await fs.stat(dir);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return [];
    }
    throw error;
  }

  if (!stats.isDirectory()) {
    return [];
  }

  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        return collectSynaxariumFiles(fullPath);
      }
      if (entry.isFile() && entry.name.endsWith('.json')) {
        return [fullPath];
      }
      return [];
    }),
  );

  return files.flat();
}

function toContentKey(contentRelativePath: string): string {
  const normalized = contentRelativePath.replace(/\\/g, '/');
  const dir = path.posix.dirname(normalized);
  const baseName = path.posix.basename(normalized, '.md');
  const lastDot = baseName.lastIndexOf('.');
  if (lastDot === -1) {
    throw new Error(`Invalid content filename "${normalized}". Expected pattern <name>.<lang>.md`);
  }
  const identifier = baseName.slice(0, lastDot);
  const language = baseName.slice(lastDot + 1);
  const prefix = dir === '.' ? '' : `${dir}/`;
  return `${prefix}${identifier}:${language}`;
}

function createEntries(files: string[]): Entry[] {
  return files
    .map((file) => {
      const contentRelativePath = path.relative(CONTENT_DIR, file);
      const key = toContentKey(contentRelativePath);
      const projectRelative = path.relative(path.resolve(__dirname, '..'), file).replace(/\\/g, '/');
      const importPath = `../${projectRelative}`;
      return { key, importPath };
    })
    .sort((a, b) => a.key.localeCompare(b.key));
}

function toSynaxariumKey(contentRelativePath: string): string {
  const normalized = contentRelativePath.replace(/\\/g, '/');
  const segments = normalized.split('/');
  if (segments.length !== 3) {
    throw new Error(`Invalid synaxarium path "${normalized}". Expected format <lang>/<month>/<day>.json`);
  }
  const [lang, monthSegment, filename] = segments;
  const daySegment = path.posix.basename(filename, '.json');
  const month = Number.parseInt(monthSegment, 10);
  const day = Number.parseInt(daySegment, 10);
  if (!Number.isFinite(month) || !Number.isFinite(day)) {
    throw new Error(`Invalid synaxarium coordinates in "${normalized}".`);
  }
  return `${lang}-${month}-${day}`;
}

function createSynaxariumEntries(files: string[]): Entry[] {
  return files
    .map((file) => {
      const contentRelativePath = path.relative(SYNAXARIUM_DIR, file);
      const key = toSynaxariumKey(contentRelativePath);
      const projectRelative = path
        .relative(path.resolve(__dirname, '..'), file)
        .replace(/\\/g, '/');
      const importPath = `../${projectRelative}`;
      return { key, importPath };
    })
    .sort((a, b) => a.key.localeCompare(b.key));
}

async function writeContentMap(entries: Entry[]): Promise<void> {
  const lines = entries.map((entry) => `  '${entry.key}': () => require('${entry.importPath}'),`);
  const source = `// This file is auto-generated by scripts/build-content-map.ts\n` +
    `// Do not edit manually as changes will be overwritten.\n\n` +
    `export const contentMap: Record<string, () => number> = {\n${lines.join('\n')}\n};\n\n` +
    `export type ContentKey = keyof typeof contentMap;\n`;
  await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true });
  await fs.writeFile(OUTPUT_FILE, source, 'utf8');
}

async function writeSynaxariumMap(entries: Entry[]): Promise<void> {
  const lines = entries.map((entry) => `  '${entry.key}': () => require('${entry.importPath}'),`);
  const body = lines.length > 0 ? `\n${lines.join('\n')}\n` : '\n';
  const source = `// This file is auto-generated by scripts/build-content-map.ts\n` +
    `// Do not edit manually as changes will be overwritten.\n\n` +
    `export const synaxariumMap: Record<string, () => any> = {${body}};\n\n` +
    `export type SynaxariumMapKey = keyof typeof synaxariumMap;\n`;
  await fs.mkdir(path.dirname(SYNAXARIUM_OUTPUT_FILE), { recursive: true });
  await fs.writeFile(SYNAXARIUM_OUTPUT_FILE, source, 'utf8');
}

async function main() {
  const files = await collectMarkdownFiles(CONTENT_DIR);
  const entries = createEntries(files);
  await writeContentMap(entries);
  const synaxariumFiles = await collectSynaxariumFiles(SYNAXARIUM_DIR);
  const synaxariumEntries = createSynaxariumEntries(synaxariumFiles);
  await writeSynaxariumMap(synaxariumEntries);
  // eslint-disable-next-line no-console
  console.log(`Generated content map with ${entries.length} entries.`);
  // eslint-disable-next-line no-console
  console.log(`Generated synaxarium map with ${synaxariumEntries.length} entries.`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
